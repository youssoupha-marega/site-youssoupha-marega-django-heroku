"""
Exemple de refactoring de app_projet pour utiliser les classes de base.

AVANT (app_projet/models.py) - Code dupliqu√© :
-----------------------------------------------
class Project(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(max_length=200, unique=True)
    resume = models.TextField()
    content = RichTextUploadingField()
    is_published = models.BooleanField(default=True)
    featured = models.BooleanField(default=False)
    author_name = models.CharField(max_length=100, default="Youssoupha Marega")
    author_email = models.EmailField(default="contact@youssouphamarega.com")
    published_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    # ... 15+ lignes de champs r√©p√©t√©s
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super().save(*args, **kwargs)


APR√àS - Utilise PublishableContent :
-------------------------------------
from app_acceuil.base_models import PublishableContent, PublishableContentManager
from ckeditor_uploader.fields import RichTextUploadingField

class Project(PublishableContent):
    '''Projet portfolio - h√©rite de PublishableContent pour √©viter la duplication.'''
    
    # Seuls les champs SP√âCIFIQUES aux projets
    content = RichTextUploadingField(verbose_name="Contenu d√©taill√©")
    main_image = models.ImageField(
        upload_to='projets/', 
        blank=True, 
        null=True, 
        verbose_name="Image principale"
    )
    github_url = models.URLField(blank=True, verbose_name="Lien GitHub")
    demo_url = models.URLField(blank=True, verbose_name="Lien d√©mo")
    
    objects = PublishableContentManager()
    
    class Meta(PublishableContent.Meta):
        verbose_name = "Projet"
        verbose_name_plural = "Projets"


VIEWS REFACTORIS√âES (app_projet/views.py) :
--------------------------------------------
from app_acceuil.base_views import ProfileBasedListView, ProfileBasedDetailView
from .models import Project

class ProjectListView(ProfileBasedListView):
    model = Project
    template_name = 'app_projet/list.html'
    context_object_name = 'projets'
    profile_featured_attr = 'featured_projects'

class ProjectDetailView(ProfileBasedDetailView):
    model = Project
    template_name = 'app_projet/detail.html'
    context_object_name = 'projet'

# Avant : 50+ lignes par vue
# Apr√®s : 5 lignes par vue !


URLS SIMPLIFI√âES (app_projet/urls.py) :
----------------------------------------
from django.urls import path
from .views import ProjectListView, ProjectDetailView

urlpatterns = [
    path('', ProjectListView.as_view(), name='projet_list'),
    path('<slug:slug>/', ProjectDetailView.as_view(), name='projet_detail'),
]


B√âN√âFICES :
-----------
‚úÖ 70% moins de code dupliqu√©
‚úÖ Modifications centralis√©es (1 endroit au lieu de 3)
‚úÖ Tests partag√©s (test une fois, b√©n√©ficie partout)
‚úÖ Nouvelles fonctionnalit√©s automatiques (ajouter un champ dans PublishableContent = disponible partout)
‚úÖ Apps restent s√©par√©es (r√©utilisables ind√©pendamment)
‚úÖ Migration progressive possible (refactorer une app √† la fois)


ALTERNATIVE : App unifi√©e "portfolio_content"
----------------------------------------------
Si vraiment vous voulez tout fusionner :

class PortfolioItem(models.Model):
    CONTENT_TYPES = (
        ('project', 'Projet'),
        ('blog', 'Article de blog'),
        ('service', 'Service'),
    )
    
    content_type = models.CharField(max_length=20, choices=CONTENT_TYPES)
    title = models.CharField(max_length=200)
    # ... tous les champs de tous les types
    
    # Champs optionnels selon le type
    github_url = models.URLField(blank=True)  # Seulement pour projets
    calendly_url = models.URLField(blank=True)  # Seulement pour services
    
    class Meta:
        verbose_name_plural = "Contenus Portfolio"

‚ö†Ô∏è INCONV√âNIENTS de l'app unifi√©e :
- Beaucoup de champs null=True, blank=True
- Validation complexe (certains champs requis selon content_type)
- Admin confus (tous les champs visibles m√™me si non pertinents)
- Performances (index sur plein de colonnes nulles)


CONCLUSION :
------------
üëâ Je recommande l'APPROCHE HYBRIDE (apps s√©par√©es + classes de base)

Raisons :
1. Meilleur des deux mondes
2. Migration progressive sans casser le code existant
3. Conserve la clart√© conceptuelle (Project != BlogPost)
4. √âlimine 70% de la duplication quand m√™me
5. Facilite les tests et la maintenance
"""
